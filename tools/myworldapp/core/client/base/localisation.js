// Copyright: IQGeo Limited 2010-2023
import $ from 'jquery';
import { trace as mywTrace } from 'myWorld/base/trace';
import i18n from 'i18next';
import Fetch from 'i18next-fetch-backend';

const trace = mywTrace('i18n');

export class Localisation {
    /** base path to obtain core locale files from. Defaults to 'locales'
     * To modify, needs to be set before call to init()
     * @type {string}
     * @example
     * localisation.defaultLocaleDirectory = 'modules/custom/core_locales'
     * */
    defaultLocaleDirectory = 'locales';

    /**
     * @class  Encapsulates localisation facilities for myWorld client
     * @constructs
     */
    constructor() {
        this.i18n = i18n;

        this.language = this._getUrlParam('lang') || navigator.language;

        //ENH: add a "installed languages" configuration so that we could prevent
        // missing files from being requested (ex: simplify 'en-GB' to 'en')

        this._initialized = new Promise(resolve => {
            this._initializedResolve = resolve;
        });

        //setup warning if init() is not called
        setTimeout(() => {
            if (!this._initCalled)
                console.log(
                    'Warning: Localisation has not been initialized. Call localisation.init()'
                );
        }, 5000);

        /** Will resolve when initialized and all requested namespaces have been loaded
         * @type {Promise} */
        this.ready = new Promise(resolve => {
            this._readyResolve = resolve;
        });

        //  Keeps track of all of the promises generated by this class, used in conjunction with this.ready
        this._readyQueue = [];
    }

    /**
     * @type {Promise}
     */
    get initialized() {
        if (!this._initialized)
            throw new Error('Localisation has not been initialized. Call localisation.init()');
        return this._initialized;
    }

    get chacheBust() {
        return this._chacheBust ?? '';
    }
    set chacheBust(value) {
        this._chacheBust = value;
    }

    /**
     * Adds a promise to a queue and resolves the ready promise when they are all fulfilled
     * @param {Promise} promise The promise to add to the tracking queue
     */
    _addToReadyQueue(promise) {
        this._readyQueue.push(promise);
        //  Once the promise is resolved, remove it from the list. Once all promises in the list are resolved, resolve the ready promise
        promise.then(() => {
            this._readyQueue = this._readyQueue.filter(r => r !== promise);
            if (this._readyQueue.length == 0) {
                this._readyResolve();
            }
        });
    }

    /**
     * Initialise localisation
     * @param  {Array<string>}  namespaces
     * @param  {object}     [options]
     * @param  {string[]}   [options.languages=['en']]   List of languages localised in the system.
     * @param  {string}     [options.localeDirectory='locales']   Locale directory. Defaults to 'locales'
     * @param  {string}     [options.baseUrl='']   Base url for locales directory
     * @return {Promise}
     */
    init(namespaces = [], options = {}) {
        this._initCalled = true;
        //include system.settings file as we'll need it to set font-family
        namespaces = ['myw.system.settings'].concat(namespaces);
        const { languages = ['en'] } = options;
        const langFamily = this.language ? this.language.split('-')[0] : this.language;
        const isExpectedLang = languages.includes(this.language) || languages.includes(langFamily);
        this.languageAsPerSetting =
            isExpectedLang && (languages.includes(this.language) ? this.language : langFamily);
        //  Use the first language in the list of expected languages as the fallback
        const fallbackLng = languages[0];

        const { localeDirectory = (options.baseUrl ?? '') + this.defaultLocaleDirectory } = options;
        const newPromise = i18n
            .use(Fetch)
            .init({
                interpolation: { prefix: '__', suffix: '__' },
                backend: {
                    fetch: window.fetch, //  This may look redundant, but we need this for when Cordova overrides window.fetch in native apps
                    loadPath: `${localeDirectory}/__lng__/__ns__.msg${this.chacheBust}`
                },
                ns: namespaces,
                defaultNS: namespaces[0],
                fallbackNS: namespaces,
                lng: this.languageAsPerSetting || fallbackLng, //  Use fallback here to force default language if not in expected list
                fallbackLng, //  Use fallback here as well in case expected language has no msg files
                debug: false,
                returnObjectTrees: true,
                getAsync: true, // Do not set to false;  leads loading timeout problems with libraries
                useCookie: false,
                ...options
            })
            .then(() => {
                // Set the font family for the application if its is provided message file
                // (this over-rides the font-family set in CSS)
                $('body').css('font-family', this.msg('Font', 'font-family'));

                this._initializedResolve();
            });
        this._addToReadyQueue(newPromise);
        return newPromise;
    }

    /**
     * Load name spaces from specified locale directory
     * @param  {Array<string>} namespaces           List of Namespace names. For example ['myw.redline']
     * @param  {string} [localeDirectory]   Locale directory. Defaults to 'locales'
     * @param  {object} [options]
     * @param  {boolean} [options.overrides=false] If set to true, messages can override messages in previously loaded namespaces
     * @return {Promise}
     */
    loadNamespaces(namespaces, localeDirectory, options = {}) {
        const { overrides = false } = options;
        localeDirectory = localeDirectory || 'locales';

        const promise = new Promise((resolve, reject) => {
            const newPath = localeDirectory + '/__lng__/__ns__.msg' + this.chacheBust;

            //ensure we've initialized before proceeding
            this.initialized.then(() => {
                this.i18n.services.backendConnector.backend.options.loadPath = newPath;
                this.i18n.loadNamespaces(namespaces, () => {
                    if (overrides) {
                        const without = this.i18n.options.fallbackNS.filter(
                            ns => !namespaces.includes(ns)
                        );
                        this.i18n.options.fallbackNS = [...namespaces, ...without];
                    }
                    resolve();
                });
            }, reject);
        });

        this._addToReadyQueue(promise);
        return promise;
    }

    /**
     * Load name space from specified locale directory
     * @param  {string} namespace           Namespace name. For example 'myw.redline'
     * @param  {string} [localeDirectory]   Locale directory. Defaults to 'locales'
     * @param  {object} [options]
     * @param  {boolean} [options.overrides=false] If set to true, messages can override messages in previously loaded namespaces
     * @return {Promise}
     * @example
     * localisation.loadNamespace('custom.client', `modules/dev_db/locales`, { override: true });
     */
    loadNamespace(namespace, localeDirectory, options) {
        return this.loadNamespaces([namespace], localeDirectory, options);
    }

    /**
     * Load name space for a module
     * @param  {string} moduleName Name of module
     * @param  {'client'|'config'} [application] Identifies if should load client or configuration file. Defaults to 'client'
     * @param  {object} [options]
     * @param  {boolean} [options.overrides=false] If set to true, messages can override messages in previously loaded namespaces
     * @return {Promise}
     * @example
     * localisation.loadModuleLocale('dev_db');
     */
    loadModuleLocale(moduleName, application = 'client', options) {
        const appSuff = application == 'client' ? '' : '.' + application;
        return this.loadNamespace(moduleName + appSuff, `modules/${moduleName}/locales`, options);
    }

    /**
     * Walks over DOM tree and translates messages
     * @param  {string|object} groupOrObject Either name of message group or object to look for messageGroup on. If
     * the latter and the message is not found, then the message be looked for on the parent class of the object.
     * @param  {jQuerySelector} selector jQuery selector for DOM tree.
     * @return {Promise}  Resolves when translation has finished
     */
    translate(groupOrObject, selector) {
        return this.ready.then(() => {
            trace(3, 'Start DOM translate ' + selector.selector);
            this._translate(groupOrObject, selector);
            trace(3, 'End DOM translate');
        });
    }

    /**
     * Translate the inner HTML of an element
     * @param  {string|object} groupOrObject Either name of message group or object to look for messageGroup on. If
     * the latter and the message is not found, then the message be looked for on the parent class of the object.
     * @param  {element} Element
     * @return {Promise}  Resolves when translation has finished
     */
    translateElement(groupOrObject, element) {
        return this.ready.then(() => {
            trace(3, 'Start element translate ');
            element.text = this.translateHtml(groupOrObject, element.text);
            trace(3, 'End element translate');
        });
    }

    /**
     * Translate HTML string
     * @param  {string|object} groupOrObject Either name of message group or object to look for messageGroup on. If
     * the latter and the message is not found, then the message be looked for on the parent class of the object.
     * @param {string} string to translate
     */
    translateHtml(groupOrObject, string) {
        const list = string.match(/{:(.*?)}/g);
        let i;
        let key;
        let value;

        if (!list) return string;

        for (i = 0; i < list.length; i++) {
            key = list[i].substring(2, list[i].length - 1);
            value = this.msg(groupOrObject, key);
            string = string.replace(list[i], value);
        }
        return string;
    }

    _translate(groupOrObject, selector) {
        let n, i, k;

        // Find text nodes with tag prefix and translate them)
        let nodes = selector
            .find('*')
            .contents()
            .filter(function () {
                //'this' will be jquery element - don't convert to arrow function
                return this.nodeType == 3 && this.data?.[0]?.indexOf('{:');
            });

        for (i = 0; i < nodes.length; i++) {
            n = nodes[i];
            n.data = this.translateHtml(groupOrObject, n.data);
        }

        // Find these attributes and translate them
        // ENH ID is needed for print layouts. Maybe make it optional
        const attrNames = ['title', 'alt', 'id', 'label'];

        for (k = 0; k < attrNames.length; k++) {
            const attrName = attrNames[k];
            nodes = selector.find('[' + attrName + "*='{:']");

            for (i = 0; i < nodes.length; i++) {
                n = $(nodes[i]);
                const attrValue = n.attr(attrName);

                // ENH Some cases the attr value is undefined even though it was picked up
                // in the find
                if (attrValue) n.attr(attrName, this.translateHtml(groupOrObject, attrValue));
            }
        }
    }

    /**
     * Translation function.
     * @param  {string|object} groupOrObject Either name of message group or object to look for messageGroup on. If
     * the latter and the message is not found, then the message be looked for on the parent class of the object.
     * @param  {string} [messageId] Message key
     * @param  {Object<string,string>} [positional] Values for positional parameters in message string
     * @return {string|function} Translated message or curried function
     */
    msg(groupOrObject, messageId, positional) {
        if (!messageId) return this.msg.bind(this, groupOrObject);
        let groupId;
        let proto;
        if (typeof groupOrObject == 'string') {
            // Replace / with . This sorts of groupOrObject strings can arising from config application where we
            // use the 'type' value which can sometimes be hierarchical (such as replicas/extract)
            groupId = groupOrObject.replace('/', '_');
        } else {
            //groupOrObject is an object
            //get groupId from 'messageGroup in prototype, defaulting to class name
            proto = Object.getPrototypeOf(groupOrObject);
            groupId = groupIdFromProto(proto);
        }

        if (!groupId) return messageId;

        let msg = this._msgInHierarchy(groupId, proto, messageId, positional);

        if (msg === undefined) msg = groupId + '.' + messageId; // return id showing missing message

        return msg;
    }

    // looks up message in hierarchy
    // tries both following myw_inherit_from message and given prototype (optional)
    _msgInHierarchy(groupId, proto, messageId, positional) {
        let msg = this._msg(groupId, messageId, positional);
        if (!isTranslated(msg)) {
            //try going up group in myw_inherit_from
            const inhGroupId = this._msg(groupId, 'myw_inherit_from');
            if (inhGroupId)
                msg = this._msgInHierarchy(inhGroupId, undefined, messageId, positional);

            if (!isTranslated(msg) && proto) {
                //try going up prototype chain
                proto = Object.getPrototypeOf(proto);
                const superGroupId = groupIdFromProto(proto);
                msg = this._msgInHierarchy(superGroupId, proto, messageId, positional);
            }
        }
        return msg;
    }

    // Looks up message
    _msg(prefix, messageId, positional) {
        let key,
            s,
            kprefix = '';

        if (prefix) {
            kprefix = prefix + '.';
        }

        const options = { returnObjects: true };
        if (positional) {
            Object.assign(options, positional);
        }

        key = kprefix + messageId;

        s = this.i18n.t(key, options);
        if (s === key) return undefined;
        return s;
    }

    _getUrlParam(name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');

        const regexS = '[\\?&]' + name + '=([^&#]*)';
        const regex = new RegExp(regexS);
        const results = regex.exec(window.location.href);

        if (results === null) {
            return '';
        } else {
            return results[1];
        }
    }

    // Utility for finding all text nodes in the DOM that are not composed entirely of whitespace.
    findAll() {
        let i;
        let n;
        const result = document.evaluate(
            './/text()',
            document,
            null,
            XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,
            null
        );

        for (i = 0; i < result.snapshotLength; i++) {
            n = result.snapshotItem(i);
            if (n.data.length > 0 && !n.data.match(/\s+/)) {
                // Go up looking for ancestor with an id. Helps to locate text in application
                let parent = n.parentElement,
                    id = '';
                while (parent) {
                    if (parent.id) {
                        id = parent.id;
                        break;
                    }
                    parent = parent.parentElement;
                }
                console.log(id, n.data);
            }
        }
    }
}

function isTranslated(msg) {
    return !(msg === undefined || (msg.startsWith && msg.startsWith('plural_not_found')));
}

/**
 * Returns the value of messageGroup set on the given prototype (not on parents)
 * If not set returns the corresponding constructor/class name
 * @param {object} proto A class prototype
 * @returns {string} group id
 */
function groupIdFromProto(proto) {
    if (!proto) return;
    return (Object.hasOwn(proto, 'messageGroup') && proto.messageGroup) || proto.constructor.name;
}

// instantiate
export const localisation = new Localisation();

/**
 * Translate a message
 * @param  {string} messageGroup Name of message group
 * @param  {string} [messageId]    ID of message
 * @param  {Object<string,string>} [positional]   Values for positional parameters in message string
 * @return {string|function} Translated message
 */
export function msg(messageGroup, messageId, positional) {
    return localisation.msg(messageGroup, messageId, positional);
}

/**
 * Walks over DOM tree and translates messages
 * @param  {JQuery.Selector} [selector] jQuery selector for DOM tree.
 */
export function translate(groupOrObject, selector) {
    return localisation.translate(groupOrObject, selector);
}

export function translateElement(groupOrObject, element) {
    return localisation.translateElement(groupOrObject, element);
}

/**
 * @class A class providing localisation methods
 */
export class Localisable {
    /**
     * Returns a localized message.
     * Self's class will be used as the message group.
     * @param  {string}     messageId       Message key
     * @param  {Object<string,string>}     [positional]    Values for positional parameters in message
     * @return {string | Function}     Translated message
     */
    msg(messageId, positional) {
        return localisation.msg(this, messageId, positional);
    }

    /**
     * Walks over DOM tree and translates messages.
     * Self's class will be used as the message group
     * @param  {JQuery.Selector}  selector    jQuery selector for DOM tree.
     */
    translate(selector) {
        return localisation.translate(this, selector);
    }
}

export default localisation;
