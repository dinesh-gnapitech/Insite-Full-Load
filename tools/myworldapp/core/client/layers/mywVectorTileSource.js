// Copyright: IQGeo Limited 2010-2023
import VectorTileSource from 'ol/source/VectorTile';
import { loadFeaturesXhr } from 'ol/featureloader.js';
import { get as getProjection, fromUserResolution, fromUserExtent } from 'ol/proj.js';

const wgs84projection = getProjection('EPSG:4326');

/**
 * Source for vector tile generated by the server
 */
export class MywVectorTileSource extends VectorTileSource {
    /**
     * @param {object} See {ol/source/Vector}
     * @extends {ol/source/Vector}
     */
    constructor(options) {
        const tileLoadFunction = (tile, url) => {
            tile.setLoader(
                /**
                 * @param {Extent} extent Extent.
                 * @param {number} resolution Resolution.
                 * @param {Projection} projection Projection.
                 */
                function (extent, resolution, projection) {
                    loadFeaturesXhr(
                        url,
                        tile.getFormat(),
                        extent,
                        resolution,
                        wgs84projection,
                        tile.onLoad.bind(tile),
                        tile.onError.bind(tile)
                    );
                }
            );
        };
        const { handleResultsCallback, ...superOptions } = options;
        super({ ...superOptions, tileLoadFunction });
        this.handleResultsCallback = handleResultsCallback;
    }

    /**
     * Overridden as the loaded extents concept doesn't work with our services
     * (it may be necessary to issue a new request to get more feature types - visible at different zoom levels)
     * @param {ol/Extent} extent Extent.
     * @param {number} userResolution Resolution.
     * @param {ProjectionLike} userProjection Projection.
     */
    loadFeatures(userExtent, userResolution, userProjection) {
        const proj3857 = getProjection('EPSG:3857');
        // transform to web mercator projection before creating the tile requests
        const resolution = fromUserResolution(userResolution, proj3857);
        const extent = fromUserExtent(userExtent, proj3857);

        const tileGrid = this.getTileGridForProjection(proj3857);
        const z = tileGrid.getZForResolution(resolution, this.zDirection);
        // const tileResolution = tileGrid.getResolution(z);
        const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);

        for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
            for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
                //ENH: include the following code
                //   if (
                //     rotation &&
                //     !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)
                //   ) {
                //     continue;
                //   }
                const pixelRatio = 1;
                let tile = this.getTile(z, x, y, pixelRatio, proj3857);

                this.getSourceTiles(pixelRatio, userProjection, tile).forEach(sourceTile => {
                    sourceTile.setFeatures = features => {
                        sourceTile.constructor.prototype.setFeatures.apply(sourceTile, features);

                        features.forEach(feature =>
                            feature.getGeometry().transform(proj3857, userProjection)
                        );

                        this.handleResultsCallback(features);
                    };
                });
            }
        }
    }
}

export default MywVectorTileSource;
