import MVT from 'ol/format/MVT';
import Feature from 'ol/Feature.js';

export class MywMVTFormat extends MVT {
    static replacements = {
        '(': '_',
        ',': '_',
        ' ': '',
        ')': ''
    };
    static mvtQueryFieldMapping = function (fields) {
        //should match code in server's MywPostGISMVTQuery code
        return Object.entries(fields).reduce((result, [key, field]) => {
            const type = field.type;
            const mappedKey = `${key}_${type.replace(/[\(, \)]/g, m => this.replacements[m])}`;
            result[mappedKey] = key;
            return result;
        }, {});
    };

    constructor(ds) {
        super({ featureClass: Feature });
        this.ds = ds;
    }

    /**
     * @private
     * @param {PBF} pbf PBF
     * @param {Object} rawFeature Raw Mapbox feature.
     * @param {OlFeature.ReadOptions} options Read options.
     * @return {OlFeature.FeatureLike|null} Feature.
     */
    createFeature_(pbf, rawFeature, options) {
        const featureType = rawFeature.properties.feature_type;
        const featureDD = this.ds.featuresDD[featureType];
        const fields = featureDD?.fields;

        if (fields) {
            //map property names generated by SQL to expected names
            Object.entries(rawFeature.properties).forEach(([key, value]) => {
                if (!fields[key]) {
                    if (!featureDD.mvtQueryFieldMapping)
                        featureDD.mvtQueryFieldMapping = MywMVTFormat.mvtQueryFieldMapping(fields);
                    const fieldName = featureDD.mvtQueryFieldMapping[key];
                    if (fieldName) rawFeature.properties[fieldName] = value;
                }
            });
        }
        return super.createFeature_(pbf, rawFeature, options);
    }
}

export default MywMVTFormat;
